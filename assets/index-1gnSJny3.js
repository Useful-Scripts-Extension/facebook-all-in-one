import{ay as v,r as e}from"./index-BFPfPAaZ.js";var w=typeof v=="object"&&v&&v.Object===Object&&v,S=typeof self=="object"&&self&&self.Object===Object&&self;w||S||Function("return this")();var O=typeof window<"u"?e.useLayoutEffect:e.useEffect;function A(n,c){const f=e.useRef(n);O(()=>{f.current=n},[n]),e.useEffect(()=>{const t=setInterval(()=>{f.current()},c);return()=>{clearInterval(t)}},[c])}function G({threshold:n=0,root:c=null,rootMargin:f="0%",freezeOnceVisible:t=!1,initialIsIntersecting:d=!1,onChange:p}={}){var I;const[u,E]=e.useState(null),[r,h]=e.useState(()=>({isIntersecting:d,entry:void 0})),y=e.useRef();y.current=p;const i=((I=r.entry)==null?void 0:I.isIntersecting)&&t;e.useEffect(()=>{if(!u||!("IntersectionObserver"in window)||i)return;let o;const a=new IntersectionObserver(j=>{const R=Array.isArray(a.thresholds)?a.thresholds:[a.thresholds];j.forEach(l=>{const b=l.isIntersecting&&R.some(m=>l.intersectionRatio>=m);h({isIntersecting:b,entry:l}),y.current&&y.current(b,l),b&&t&&o&&(o(),o=void 0)})},{threshold:n,root:c,rootMargin:f});return a.observe(u),()=>{a.disconnect()}},[u,JSON.stringify(n),c,f,i,t]);const g=e.useRef(null);e.useEffect(()=>{var o;!u&&((o=r.entry)!=null&&o.target)&&!t&&!i&&g.current!==r.entry.target&&(g.current=r.entry.target,h({isIntersecting:d,entry:void 0}))},[u,r.entry,t,i,d]);const s=[E,!!r.isIntersecting,r.entry];return s.ref=s[0],s.isIntersecting=s[1],s.entry=s[2],s}export{A as a,G as u};
